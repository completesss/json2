{
   "history":[
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"gradient",
         "speed":0.25,
         "trackMouse":0,
         "mouseMomentum":0,
         "animating":false,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos; vec3 getColor(int index) { switch(index) { case 0: return vec3(0, 0, 0); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0); }void main() { vec2 uv = vTextureCoord; vec2 pos = vec2(0.4894319682959049, 0.5052840158520475) + mix(vec2(0), (uMousePos-0.5), 0.00); uv -= pos; uv /= (0.53*2.); uv = rotate(uv, (1.00 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1); fragColor = color; }"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"mouse",
         "parentLayer":"1e59e030-e7d3-48a9-a5aa-f9b012861efd",
         "animating":false,
         "mouseMomentum":0,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision highp float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; uniform vec2 uResolution;const float PI = 3.1415926; const float ITERATIONS = 24.0;float getGaussianWeight(int index) { switch(index) { case 0: return 0.7978845608028654; case 1: return 0.795118932516684; case 2: return 0.7868794322038799; case 3: return 0.7733362336056986; case 4: return 0.7547664553859864; case 5: return 0.7315447328280048; case 6: return 0.704130653528599; case 7: return 0.6730536454899063; case 8: return 0.6388960110447045; case 9: return 0.6022748643096089; case 10: return 0.5638237508206051; case 11: return 0.5241747061566029; case 12: return 0.48394144903828673; case 13: return 0.443704309411472; case 14: return 0.40399737110811773; case 15: return 0.36529817077804383; case 16: return 0.3280201493519873; case 17: return 0.29250790855907144; case 18: return 0.2590351913317835; case 19: return 0.2278053882403838; case 20: return 0.19895427758549736; case 21: return 0.17255463765302306; case 22: return 0.1486223271179862; case 23: return 0.12712341303392466; default: return 0.0; } }out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec3 chromatic_aberration(vec3 color, vec2 uv, vec2 offset) { vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }vec2 angleToDir(float angle) { float rad = angle * 2.0 * PI; return vec2(cos(rad), sin(rad)); }vec4 blurTrail(vec2 uv, vec2 mouseDir) { vec2 distorted = mouseDir * 0.4; float total_weight = 0.0; vec4 color = vec4(0);for (int i = 0; i <= 24; i++) { float scale = 0.0001 + 1.00 * 0.5; float weight = getGaussianWeight(i); vec2 offset = distorted * (1.5 + scale) * mix(1.0, float(i) / ITERATIONS, scale); vec4 samp = texture(uTexture, uv - offset); samp.rgb = chromatic_aberration(samp.rgb, uv - offset, offset * 1.00 * 0.12); color += weight * samp; total_weight += weight; } return color / total_weight; }vec4 getTrailColor(vec2 uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); float aspectRatio = uResolution.x / uResolution.y;return blurTrail(uv, mouseDir); }void main() { vec2 uv = vTextureCoord; vec2 pingpongUv = uv;vec3 mouseRgb = texture(uPingPongTexture, pingpongUv).rgb; vec3 mouseTrail = rgb2hsv(mouseRgb);float angle = mouseTrail.x; float strength = mouseTrail.z * (0.32 * 2.0); vec2 direction = angleToDir(angle); vec2 mouseDir = direction * strength;vec4 color = getTrailColor(uv, mouseDir, strength);fragColor = color; }",
            "#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uPingPongTexture; uniform vec2 uPreviousMousePos; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.1415926; const float TWOPI = 6.2831852;out vec4 fragColor;vec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 liquify(vec2 st, float angle) { float aspectRatio = uResolution.x / uResolution.y; st.x *= aspectRatio; st = st * rot(angle * TWOPI); float amplitude = 0.003; for (float i = 1.0; i <= 5.0; i++) { st = st * rot(i / 5.0 * PI * 2.0); st += vec2( amplitude * cos(i * 5.0 * st.y + uTime * 0.02), amplitude * sin(i * 5.0 * st.x + uTime * 0.02) ); } st = st * rot(-angle * TWOPI); st.x /= aspectRatio; return st; }void main() { float aspectRatio = uResolution.x / uResolution.y; vec2 uv = vTextureCoord; vec2 correctedUv = uv * vec2(aspectRatio, 1.0);vec2 dir = (uMousePos - uPreviousMousePos) * vec2(aspectRatio, 1.0); float dist = length(dir); dir = normalize(dir);float rad = 0.54 * 0.4 * mix(aspectRatio, 1.0, 0.5); float angle = atan(dir.y, dir.x); if (angle < 0.0) angle += TWOPI;uv = mix(uv, liquify(uv, smoothstep(0.0, 1.0, angle)), 1.00);float t = clamp(dot(correctedUv - uPreviousMousePos * vec2(aspectRatio, 1.0), dir) / dist, 0.0, 1.0); vec2 closestPoint = mix(uPreviousMousePos, uMousePos, t) * vec2(aspectRatio, 1.0); float distanceToLine = distance(correctedUv, closestPoint);float s = smoothstep(rad, rad * 0.00, distanceToLine);vec3 color = vec3(angle / TWOPI, 1.0, 1.0); vec3 mouseColor = hsv2rgb(color);vec3 lastFrameColor = texture(uPingPongTexture, mix(uv, uv / 1.03 + 0.015, 1.00)).rgb; vec3 draw = mix(lastFrameColor, mouseColor, min(1.0, dist * s));fragColor = vec4(draw * pow(1.00, 0.1), 1.0); }"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }",
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "locked":false,
         "aspectRatio":1,
         "layerName":"",
         "isElement":true,
         "opacity":0.3999999999999999,
         "displace":0,
         "trackMouse":0.05,
         "mouseMomentum":0,
         "blendMode":"NORMAL",
         "bgDisplace":0,
         "mask":0,
         "maskBackground":{
            "type":"Vec3",
            "_x":0,
            "_y":0,
            "_z":0
         },
         "maskAlpha":0,
         "maskDepth":0,
         "dispersion":0,
         "axisTilt":0,
         "states":{
            "appear":[
               
            ],
            "scroll":[
               
            ],
            "hover":[
               
            ]
         },
         "layerType":"shape",
         "borderRadius":0,
         "coords":[
            [
               -364,
               -248
            ],
            [
               416,
               -248
            ],
            [
               416,
               230
            ],
            [
               -364,
               230
            ]
         ],
         "effects":[
            
         ],
         "fill":[
            "#ffffff",
            "#110065",
            "#003084",
            "#005fad",
            "#017ed7"
         ],
         "fitToCanvas":false,
         "gradientAngle":0,
         "gradientType":"linear",
         "rotation":0,
         "translateX":976,
         "translateY":718,
         "type":"circle",
         "stroke":[
            "#ffffff"
         ],
         "strokeWidth":0,
         "numSides":3,
         "width":[
            -364,
            416
         ],
         "height":[
            -248,
            230
         ],
         "compiledFragmentShaders":[
            "#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.05);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 0.40);fragColor = color; }"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ]
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"beam",
         "speed":0.2,
         "trackMouse":0.05,
         "mouseMomentum":0.5,
         "animating":true,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float calculateAngle(vec2 point, vec2 center) { vec2 direction = point - center; float angle = atan(direction.y, direction.x); if (angle < 0.0) { angle += TWO_PI; } return angle; }float angularDifference(float angle1, float angle2) { float diff = abs(angle1 - angle2); if (diff > PI) { diff = TWO_PI - diff; } return diff; }float angularFading(float pointAngle, float peakAngle, float fadeAmount) { float diff = angularDifference(pointAngle, peakAngle); return 1.04 - smoothstep(0.0, fadeAmount, diff); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawRing(vec2 uv, vec2 center, float scale, float angle) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.50, 1.-0.50) * 2.; uv = uv * rot(-0.03 * TWO_PI) * skew; center = center * rot(-0.03 * TWO_PI) * skew; float ringRadius = scale * 0.5; float distFromCenter = length(uv - center); float ringDist = abs(distFromCenter - ringRadius); float lineRadius = 0.19 * 0.25; float brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));angle = fract(-0.03 + uTime * 0.01 + 0.00) * TWO_PI;float pointAngle = calculateAngle(uv, center); float peakAngle = angle; float angleFactor = angularFading(pointAngle, peakAngle, PI * 0.5);brightness *= angleFactor;vec3 ringColor = brightness * pow(1.-ringDist, 3.) * vec3(0.27058823529411763, 0.6039215686274509, 1); return ringColor; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.48, -0.010000000000000009) + mix(vec2(0), (uMousePos-0.5), 0.05); return drawRing(uv, pos, 0.64, -0.03); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.00); result += dither;fragColor = vec4(result, bg.a); }"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"beam",
         "speed":0.2,
         "trackMouse":0.05,
         "mouseMomentum":0.5,
         "animating":true,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float calculateAngle(vec2 point, vec2 center) { vec2 direction = point - center; float angle = atan(direction.y, direction.x); if (angle < 0.0) { angle += TWO_PI; } return angle; }float angularDifference(float angle1, float angle2) { float diff = abs(angle1 - angle2); if (diff > PI) { diff = TWO_PI - diff; } return diff; }float angularFading(float pointAngle, float peakAngle, float fadeAmount) { float diff = angularDifference(pointAngle, peakAngle); return 1.04 - smoothstep(0.0, fadeAmount, diff); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawRing(vec2 uv, vec2 center, float scale, float angle) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.50, 1.-0.50) * 2.; uv = uv * rot(-0.03 * TWO_PI) * skew; center = center * rot(-0.03 * TWO_PI) * skew; float ringRadius = scale * 0.5; float distFromCenter = length(uv - center); float ringDist = abs(distFromCenter - ringRadius); float lineRadius = 0.19 * 0.25; float brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));angle = fract(-0.03 + uTime * 0.01 + 0.22) * TWO_PI;float pointAngle = calculateAngle(uv, center); float peakAngle = angle; float angleFactor = angularFading(pointAngle, peakAngle, PI * 0.5);brightness *= angleFactor;vec3 ringColor = brightness * pow(1.-ringDist, 3.) * vec3(0.27058823529411763, 0.6039215686274509, 1); return ringColor; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.48, -0.010000000000000009) + mix(vec2(0), (uMousePos-0.5), 0.05); return drawRing(uv, pos, 0.74, -0.03); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.00); result += dither;fragColor = vec4(result, bg.a); }"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"beam",
         "speed":0.4,
         "trackMouse":0.05,
         "mouseMomentum":0.5,
         "animating":true,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return vec3((src.x == 1.0) ? 1.0 : min(1.0, dst.x / (1.0 - src.x)), (src.y == 1.0) ? 1.0 : min(1.0, dst.y / (1.0 - src.y)), (src.z == 1.0) ? 1.0 : min(1.0, dst.z / (1.0 - src.z))); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float calculateAngle(vec2 point, vec2 center) { vec2 direction = point - center; float angle = atan(direction.y, direction.x); if (angle < 0.0) { angle += TWO_PI; } return angle; }float angularDifference(float angle1, float angle2) { float diff = abs(angle1 - angle2); if (diff > PI) { diff = TWO_PI - diff; } return diff; }float angularFading(float pointAngle, float peakAngle, float fadeAmount) { float diff = angularDifference(pointAngle, peakAngle); return 1.04 - smoothstep(0.0, fadeAmount, diff); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawRing(vec2 uv, vec2 center, float scale, float angle) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.50, 1.-0.50) * 2.; uv = uv * rot(-0.04 * TWO_PI) * skew; center = center * rot(-0.04 * TWO_PI) * skew; float ringRadius = scale * 0.5; float distFromCenter = length(uv - center); float ringDist = abs(distFromCenter - ringRadius); float lineRadius = 0.25 * 0.25; float brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));angle = fract(-0.04 + uTime * 0.01 + 0.11) * TWO_PI;float pointAngle = calculateAngle(uv, center); float peakAngle = angle; float angleFactor = angularFading(pointAngle, peakAngle, PI * 0.5);brightness *= angleFactor;vec3 ringColor = brightness * pow(1.-ringDist, 3.) * vec3(0.8, 0, 0.9176470588235294); return ringColor; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.48, -0.010000000000000009) + mix(vec2(0), (uMousePos-0.5), 0.05); return drawRing(uv, pos, 0.53, -0.04); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(8, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.00); result += dither;fragColor = vec4(result, bg.a); }"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"beam",
         "speed":0.4,
         "trackMouse":0.05,
         "mouseMomentum":0.5,
         "animating":true,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return vec3((src.x == 1.0) ? 1.0 : min(1.0, dst.x / (1.0 - src.x)), (src.y == 1.0) ? 1.0 : min(1.0, dst.y / (1.0 - src.y)), (src.z == 1.0) ? 1.0 : min(1.0, dst.z / (1.0 - src.z))); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float calculateAngle(vec2 point, vec2 center) { vec2 direction = point - center; float angle = atan(direction.y, direction.x); if (angle < 0.0) { angle += TWO_PI; } return angle; }float angularDifference(float angle1, float angle2) { float diff = abs(angle1 - angle2); if (diff > PI) { diff = TWO_PI - diff; } return diff; }float angularFading(float pointAngle, float peakAngle, float fadeAmount) { float diff = angularDifference(pointAngle, peakAngle); return 1.04 - smoothstep(0.0, fadeAmount, diff); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawRing(vec2 uv, vec2 center, float scale, float angle) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.50, 1.-0.50) * 2.; uv = uv * rot(-0.04 * TWO_PI) * skew; center = center * rot(-0.04 * TWO_PI) * skew; float ringRadius = scale * 0.5; float distFromCenter = length(uv - center); float ringDist = abs(distFromCenter - ringRadius); float lineRadius = 0.25 * 0.25; float brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));angle = fract(-0.04 + uTime * 0.01 + 0.11) * TWO_PI;float pointAngle = calculateAngle(uv, center); float peakAngle = angle; float angleFactor = angularFading(pointAngle, peakAngle, PI * 0.5);brightness *= angleFactor;vec3 ringColor = brightness * pow(1.-ringDist, 3.) * vec3(0.8, 0, 0.9176470588235294); return ringColor; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.48, -0.010000000000000009) + mix(vec2(0), (uMousePos-0.5), 0.05); return drawRing(uv, pos, 0.43, -0.04); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(8, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.00); result += dither;fragColor = vec4(result, bg.a); }"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"beam",
         "speed":0.81,
         "trackMouse":0.05,
         "mouseMomentum":0.5,
         "animating":true,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float calculateAngle(vec2 point, vec2 center) { vec2 direction = point - center; float angle = atan(direction.y, direction.x); if (angle < 0.0) { angle += TWO_PI; } return angle; }float angularDifference(float angle1, float angle2) { float diff = abs(angle1 - angle2); if (diff > PI) { diff = TWO_PI - diff; } return diff; }float angularFading(float pointAngle, float peakAngle, float fadeAmount) { float diff = angularDifference(pointAngle, peakAngle); return 1.04 - smoothstep(0.0, fadeAmount, diff); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawRing(vec2 uv, vec2 center, float scale, float angle) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.50, 1.-0.50) * 2.; uv = uv * rot(0.10 * TWO_PI) * skew; center = center * rot(0.10 * TWO_PI) * skew; float ringRadius = scale * 0.5; float distFromCenter = length(uv - center); float ringDist = abs(distFromCenter - ringRadius); float lineRadius = 0.33 * 0.25; float brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));angle = fract(0.10 + uTime * 0.01 + 0.77) * TWO_PI;float pointAngle = calculateAngle(uv, center); float peakAngle = angle; float angleFactor = angularFading(pointAngle, peakAngle, PI * 0.5);brightness *= angleFactor;vec3 ringColor = brightness * pow(1.-ringDist, 3.) * vec3(0.3254901960784314, 1, 0.615686274509804); return ringColor; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.48, -0.010000000000000009) + mix(vec2(0), (uMousePos-0.5), 0.05); return drawRing(uv, pos, 0.40, 0.10); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 0.77); result += dither;fragColor = vec4(result, bg.a); }"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"beam",
         "speed":0.44,
         "trackMouse":0.05,
         "mouseMomentum":0.5,
         "animating":true,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float calculateAngle(vec2 point, vec2 center) { vec2 direction = point - center; float angle = atan(direction.y, direction.x); if (angle < 0.0) { angle += TWO_PI; } return angle; }float angularDifference(float angle1, float angle2) { float diff = abs(angle1 - angle2); if (diff > PI) { diff = TWO_PI - diff; } return diff; }float angularFading(float pointAngle, float peakAngle, float fadeAmount) { float diff = angularDifference(pointAngle, peakAngle); return 1.04 - smoothstep(0.0, fadeAmount, diff); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawRing(vec2 uv, vec2 center, float scale, float angle) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.50, 1.-0.50) * 2.; uv = uv * rot(0.10 * TWO_PI) * skew; center = center * rot(0.10 * TWO_PI) * skew; float ringRadius = scale * 0.5; float distFromCenter = length(uv - center); float ringDist = abs(distFromCenter - ringRadius); float lineRadius = 0.33 * 0.25; float brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));angle = fract(0.10 + uTime * 0.01 + 0.77) * TWO_PI;float pointAngle = calculateAngle(uv, center); float peakAngle = angle; float angleFactor = angularFading(pointAngle, peakAngle, PI * 0.5);brightness *= angleFactor;vec3 ringColor = brightness * pow(1.-ringDist, 3.) * vec3(0.3254901960784314, 1, 0.615686274509804); return ringColor; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.48, -0.010000000000000009) + mix(vec2(0), (uMousePos-0.5), 0.05); return drawRing(uv, pos, 0.56, 0.10); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 0.77); result += dither;fragColor = vec4(result, bg.a); }"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"beam",
         "speed":0.81,
         "trackMouse":0.05,
         "mouseMomentum":0.5,
         "animating":true,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float calculateAngle(vec2 point, vec2 center) { vec2 direction = point - center; float angle = atan(direction.y, direction.x); if (angle < 0.0) { angle += TWO_PI; } return angle; }float angularDifference(float angle1, float angle2) { float diff = abs(angle1 - angle2); if (diff > PI) { diff = TWO_PI - diff; } return diff; }float angularFading(float pointAngle, float peakAngle, float fadeAmount) { float diff = angularDifference(pointAngle, peakAngle); return 1.04 - smoothstep(0.0, fadeAmount, diff); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawRing(vec2 uv, vec2 center, float scale, float angle) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.50, 1.-0.50) * 2.; uv = uv * rot(0.08 * TWO_PI) * skew; center = center * rot(0.08 * TWO_PI) * skew; float ringRadius = scale * 0.5; float distFromCenter = length(uv - center); float ringDist = abs(distFromCenter - ringRadius); float lineRadius = 0.33 * 0.25; float brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));angle = fract(0.08 + uTime * 0.01 + 0.77) * TWO_PI;float pointAngle = calculateAngle(uv, center); float peakAngle = angle; float angleFactor = angularFading(pointAngle, peakAngle, PI * 0.5);brightness *= angleFactor;vec3 ringColor = brightness * pow(1.-ringDist, 3.) * vec3(0.3254901960784314, 1, 0.615686274509804); return ringColor; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.48, -0.010000000000000009) + mix(vec2(0), (uMousePos-0.5), 0.05); return drawRing(uv, pos, 0.67, 0.08); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 0.77); result += dither;fragColor = vec4(result, bg.a); }"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"beam",
         "speed":0.5,
         "trackMouse":0.05,
         "mouseMomentum":0.5,
         "animating":true,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float calculateAngle(vec2 point, vec2 center) { vec2 direction = point - center; float angle = atan(direction.y, direction.x); if (angle < 0.0) { angle += TWO_PI; } return angle; }float angularDifference(float angle1, float angle2) { float diff = abs(angle1 - angle2); if (diff > PI) { diff = TWO_PI - diff; } return diff; }float angularFading(float pointAngle, float peakAngle, float fadeAmount) { float diff = angularDifference(pointAngle, peakAngle); return 1.04 - smoothstep(0.0, fadeAmount, diff); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawRing(vec2 uv, vec2 center, float scale, float angle) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.50, 1.-0.50) * 2.; uv = uv * rot(0.12 * TWO_PI) * skew; center = center * rot(0.12 * TWO_PI) * skew; float ringRadius = scale * 0.5; float distFromCenter = length(uv - center); float ringDist = abs(distFromCenter - ringRadius); float lineRadius = 0.33 * 0.25; float brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));angle = fract(0.12 + uTime * 0.01 + 0.97) * TWO_PI;float pointAngle = calculateAngle(uv, center); float peakAngle = angle; float angleFactor = angularFading(pointAngle, peakAngle, PI * 0.5);brightness *= angleFactor;vec3 ringColor = brightness * pow(1.-ringDist, 3.) * vec3(0.3254901960784314, 1, 0.615686274509804); return ringColor; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.48, -0.010000000000000009) + mix(vec2(0), (uMousePos-0.5), 0.05); return drawRing(uv, pos, 0.72, 0.12); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 0.77); result += dither;fragColor = vec4(result, bg.a); }"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"beam",
         "speed":0.37,
         "trackMouse":0.05,
         "mouseMomentum":0.5,
         "animating":true,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return vec3((src.x <= 0.5) ? (dst.x - (1.0 - 2.0 * src.x) * dst.x * (1.0 - dst.x)) : (((src.x > 0.5) && (dst.x <= 0.25)) ? (dst.x + (2.0 * src.x - 1.0) * (4.0 * dst.x * (4.0 * dst.x + 1.0) * (dst.x - 1.0) + 7.0 * dst.x)) : (dst.x + (2.0 * src.x - 1.0) * (sqrt(dst.x) - dst.x))), (src.y <= 0.5) ? (dst.y - (1.0 - 2.0 * src.y) * dst.y * (1.0 - dst.y)) : (((src.y > 0.5) && (dst.y <= 0.25)) ? (dst.y + (2.0 * src.y - 1.0) * (4.0 * dst.y * (4.0 * dst.y + 1.0) * (dst.y - 1.0) + 7.0 * dst.y)) : (dst.y + (2.0 * src.y - 1.0) * (sqrt(dst.y) - dst.y))), (src.z <= 0.5) ? (dst.z - (1.0 - 2.0 * src.z) * dst.z * (1.0 - dst.z)) : (((src.z > 0.5) && (dst.z <= 0.25)) ? (dst.z + (2.0 * src.z - 1.0) * (4.0 * dst.z * (4.0 * dst.z + 1.0) * (dst.z - 1.0) + 7.0 * dst.z)) : (dst.z + (2.0 * src.z - 1.0) * (sqrt(dst.z) - dst.z)))); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float calculateAngle(vec2 point, vec2 center) { vec2 direction = point - center; float angle = atan(direction.y, direction.x); if (angle < 0.0) { angle += TWO_PI; } return angle; }float angularDifference(float angle1, float angle2) { float diff = abs(angle1 - angle2); if (diff > PI) { diff = TWO_PI - diff; } return diff; }float angularFading(float pointAngle, float peakAngle, float fadeAmount) { float diff = angularDifference(pointAngle, peakAngle); return 1.04 - smoothstep(0.0, fadeAmount, diff); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawRing(vec2 uv, vec2 center, float scale, float angle) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.50, 1.-0.50) * 2.; uv = uv * rot(0.47 * TWO_PI) * skew; center = center * rot(0.47 * TWO_PI) * skew; float ringRadius = scale * 0.5; float distFromCenter = length(uv - center); float ringDist = abs(distFromCenter - ringRadius); float lineRadius = 0.34 * 0.25; float brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));angle = fract(0.47 + uTime * 0.01 + 0.76) * TWO_PI;float pointAngle = calculateAngle(uv, center); float peakAngle = angle; float angleFactor = angularFading(pointAngle, peakAngle, PI * 0.5);brightness *= angleFactor;vec3 ringColor = brightness * pow(1.-ringDist, 3.) * vec3(0, 0.7450980392156863, 0.9725490196078431); return ringColor; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.48, -0.010000000000000009) + mix(vec2(0), (uMousePos-0.5), 0.05); return drawRing(uv, pos, 0.57, 0.47); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(12, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.00); result += dither;fragColor = vec4(result, bg.a); }"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"beam",
         "speed":0.58,
         "trackMouse":0.05,
         "mouseMomentum":0.5,
         "animating":true,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return vec3((src.x <= 0.5) ? (dst.x - (1.0 - 2.0 * src.x) * dst.x * (1.0 - dst.x)) : (((src.x > 0.5) && (dst.x <= 0.25)) ? (dst.x + (2.0 * src.x - 1.0) * (4.0 * dst.x * (4.0 * dst.x + 1.0) * (dst.x - 1.0) + 7.0 * dst.x)) : (dst.x + (2.0 * src.x - 1.0) * (sqrt(dst.x) - dst.x))), (src.y <= 0.5) ? (dst.y - (1.0 - 2.0 * src.y) * dst.y * (1.0 - dst.y)) : (((src.y > 0.5) && (dst.y <= 0.25)) ? (dst.y + (2.0 * src.y - 1.0) * (4.0 * dst.y * (4.0 * dst.y + 1.0) * (dst.y - 1.0) + 7.0 * dst.y)) : (dst.y + (2.0 * src.y - 1.0) * (sqrt(dst.y) - dst.y))), (src.z <= 0.5) ? (dst.z - (1.0 - 2.0 * src.z) * dst.z * (1.0 - dst.z)) : (((src.z > 0.5) && (dst.z <= 0.25)) ? (dst.z + (2.0 * src.z - 1.0) * (4.0 * dst.z * (4.0 * dst.z + 1.0) * (dst.z - 1.0) + 7.0 * dst.z)) : (dst.z + (2.0 * src.z - 1.0) * (sqrt(dst.z) - dst.z)))); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float calculateAngle(vec2 point, vec2 center) { vec2 direction = point - center; float angle = atan(direction.y, direction.x); if (angle < 0.0) { angle += TWO_PI; } return angle; }float angularDifference(float angle1, float angle2) { float diff = abs(angle1 - angle2); if (diff > PI) { diff = TWO_PI - diff; } return diff; }float angularFading(float pointAngle, float peakAngle, float fadeAmount) { float diff = angularDifference(pointAngle, peakAngle); return 1.04 - smoothstep(0.0, fadeAmount, diff); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawRing(vec2 uv, vec2 center, float scale, float angle) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.50, 1.-0.50) * 2.; uv = uv * rot(0.47 * TWO_PI) * skew; center = center * rot(0.47 * TWO_PI) * skew; float ringRadius = scale * 0.5; float distFromCenter = length(uv - center); float ringDist = abs(distFromCenter - ringRadius); float lineRadius = 0.34 * 0.25; float brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));angle = fract(0.47 + uTime * 0.01 + 0.76) * TWO_PI;float pointAngle = calculateAngle(uv, center); float peakAngle = angle; float angleFactor = angularFading(pointAngle, peakAngle, PI * 0.5);brightness *= angleFactor;vec3 ringColor = brightness * pow(1.-ringDist, 3.) * vec3(0, 0.7450980392156863, 0.9725490196078431); return ringColor; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.48, -0.010000000000000009) + mix(vec2(0), (uMousePos-0.5), 0.05); return drawRing(uv, pos, 0.64, 0.47); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(12, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.00); result += dither;fragColor = vec4(result, bg.a); }"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"beam",
         "speed":0.58,
         "trackMouse":0.05,
         "mouseMomentum":0.5,
         "animating":true,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return vec3((src.x <= 0.5) ? (dst.x - (1.0 - 2.0 * src.x) * dst.x * (1.0 - dst.x)) : (((src.x > 0.5) && (dst.x <= 0.25)) ? (dst.x + (2.0 * src.x - 1.0) * (4.0 * dst.x * (4.0 * dst.x + 1.0) * (dst.x - 1.0) + 7.0 * dst.x)) : (dst.x + (2.0 * src.x - 1.0) * (sqrt(dst.x) - dst.x))), (src.y <= 0.5) ? (dst.y - (1.0 - 2.0 * src.y) * dst.y * (1.0 - dst.y)) : (((src.y > 0.5) && (dst.y <= 0.25)) ? (dst.y + (2.0 * src.y - 1.0) * (4.0 * dst.y * (4.0 * dst.y + 1.0) * (dst.y - 1.0) + 7.0 * dst.y)) : (dst.y + (2.0 * src.y - 1.0) * (sqrt(dst.y) - dst.y))), (src.z <= 0.5) ? (dst.z - (1.0 - 2.0 * src.z) * dst.z * (1.0 - dst.z)) : (((src.z > 0.5) && (dst.z <= 0.25)) ? (dst.z + (2.0 * src.z - 1.0) * (4.0 * dst.z * (4.0 * dst.z + 1.0) * (dst.z - 1.0) + 7.0 * dst.z)) : (dst.z + (2.0 * src.z - 1.0) * (sqrt(dst.z) - dst.z)))); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float calculateAngle(vec2 point, vec2 center) { vec2 direction = point - center; float angle = atan(direction.y, direction.x); if (angle < 0.0) { angle += TWO_PI; } return angle; }float angularDifference(float angle1, float angle2) { float diff = abs(angle1 - angle2); if (diff > PI) { diff = TWO_PI - diff; } return diff; }float angularFading(float pointAngle, float peakAngle, float fadeAmount) { float diff = angularDifference(pointAngle, peakAngle); return 1.04 - smoothstep(0.0, fadeAmount, diff); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawRing(vec2 uv, vec2 center, float scale, float angle) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.50, 1.-0.50) * 2.; uv = uv * rot(0.47 * TWO_PI) * skew; center = center * rot(0.47 * TWO_PI) * skew; float ringRadius = scale * 0.5; float distFromCenter = length(uv - center); float ringDist = abs(distFromCenter - ringRadius); float lineRadius = 0.34 * 0.25; float brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));angle = fract(0.47 + uTime * 0.01 + 0.46) * TWO_PI;float pointAngle = calculateAngle(uv, center); float peakAngle = angle; float angleFactor = angularFading(pointAngle, peakAngle, PI * 0.5);brightness *= angleFactor;vec3 ringColor = brightness * pow(1.-ringDist, 3.) * vec3(0.4392156862745098, 0.00392156862745098, 0.8431372549019608); return ringColor; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.48, -0.010000000000000009) + mix(vec2(0), (uMousePos-0.5), 0.05); return drawRing(uv, pos, 0.64, 0.47); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(12, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.00); result += dither;fragColor = vec4(result, bg.a); }"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"beam",
         "speed":0.58,
         "trackMouse":0.07,
         "mouseMomentum":0.5,
         "animating":true,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float calculateAngle(vec2 point, vec2 center) { vec2 direction = point - center; float angle = atan(direction.y, direction.x); if (angle < 0.0) { angle += TWO_PI; } return angle; }float angularDifference(float angle1, float angle2) { float diff = abs(angle1 - angle2); if (diff > PI) { diff = TWO_PI - diff; } return diff; }float angularFading(float pointAngle, float peakAngle, float fadeAmount) { float diff = angularDifference(pointAngle, peakAngle); return 1.04 - smoothstep(0.0, fadeAmount, diff); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawRing(vec2 uv, vec2 center, float scale, float angle) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.50, 1.-0.50) * 2.; uv = uv * rot(0.41 * TWO_PI) * skew; center = center * rot(0.41 * TWO_PI) * skew; float ringRadius = scale * 0.5; float distFromCenter = length(uv - center); float ringDist = abs(distFromCenter - ringRadius); float lineRadius = 0.34 * 0.25; float brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));angle = fract(0.41 + uTime * 0.01 + 0.56) * TWO_PI;float pointAngle = calculateAngle(uv, center); float peakAngle = angle; float angleFactor = angularFading(pointAngle, peakAngle, PI * 0.5);brightness *= angleFactor;vec3 ringColor = brightness * pow(1.-ringDist, 3.) * vec3(0.396078431372549, 0.4392156862745098, 0.9882352941176471); return ringColor; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.48, -0.010000000000000009) + mix(vec2(0), (uMousePos-0.5), 0.07); return drawRing(uv, pos, 0.84, 0.41); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.00); result += dither;fragColor = vec4(result, bg.a); }"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"beam",
         "speed":0.58,
         "trackMouse":0.07,
         "mouseMomentum":0.5,
         "animating":true,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float calculateAngle(vec2 point, vec2 center) { vec2 direction = point - center; float angle = atan(direction.y, direction.x); if (angle < 0.0) { angle += TWO_PI; } return angle; }float angularDifference(float angle1, float angle2) { float diff = abs(angle1 - angle2); if (diff > PI) { diff = TWO_PI - diff; } return diff; }float angularFading(float pointAngle, float peakAngle, float fadeAmount) { float diff = angularDifference(pointAngle, peakAngle); return 1.04 - smoothstep(0.0, fadeAmount, diff); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawRing(vec2 uv, vec2 center, float scale, float angle) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.50, 1.-0.50) * 2.; uv = uv * rot(0.45 * TWO_PI) * skew; center = center * rot(0.45 * TWO_PI) * skew; float ringRadius = scale * 0.5; float distFromCenter = length(uv - center); float ringDist = abs(distFromCenter - ringRadius); float lineRadius = 0.34 * 0.25; float brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));angle = fract(0.45 + uTime * 0.01 + 0.28) * TWO_PI;float pointAngle = calculateAngle(uv, center); float peakAngle = angle; float angleFactor = angularFading(pointAngle, peakAngle, PI * 0.5);brightness *= angleFactor;vec3 ringColor = brightness * pow(1.-ringDist, 3.) * vec3(0.396078431372549, 0.4392156862745098, 0.9882352941176471); return ringColor; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.48, -0.010000000000000009) + mix(vec2(0), (uMousePos-0.5), 0.07); return drawRing(uv, pos, 0.60, 0.45); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.00); result += dither;fragColor = vec4(result, bg.a); }"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"beam",
         "speed":0.43,
         "trackMouse":0.04,
         "mouseMomentum":0.5,
         "animating":true,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return vec3((src.x == 1.0) ? 1.0 : min(1.0, dst.x / (1.0 - src.x)), (src.y == 1.0) ? 1.0 : min(1.0, dst.y / (1.0 - src.y)), (src.z == 1.0) ? 1.0 : min(1.0, dst.z / (1.0 - src.z))); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float calculateAngle(vec2 point, vec2 center) { vec2 direction = point - center; float angle = atan(direction.y, direction.x); if (angle < 0.0) { angle += TWO_PI; } return angle; }float angularDifference(float angle1, float angle2) { float diff = abs(angle1 - angle2); if (diff > PI) { diff = TWO_PI - diff; } return diff; }float angularFading(float pointAngle, float peakAngle, float fadeAmount) { float diff = angularDifference(pointAngle, peakAngle); return 1.04 - smoothstep(0.0, fadeAmount, diff); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawRing(vec2 uv, vec2 center, float scale, float angle) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.50, 1.-0.50) * 2.; uv = uv * rot(0.41 * TWO_PI) * skew; center = center * rot(0.41 * TWO_PI) * skew; float ringRadius = scale * 0.5; float distFromCenter = length(uv - center); float ringDist = abs(distFromCenter - ringRadius); float lineRadius = 0.71 * 0.25; float brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));angle = fract(0.41 + uTime * 0.01 + 1.00) * TWO_PI;float pointAngle = calculateAngle(uv, center); float peakAngle = angle; float angleFactor = angularFading(pointAngle, peakAngle, PI * 0.5);brightness *= angleFactor;vec3 ringColor = brightness * pow(1.-ringDist, 3.) * vec3(0.8, 0, 0.9176470588235294); return ringColor; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.48, -0.010000000000000009) + mix(vec2(0), (uMousePos-0.5), 0.04); return drawRing(uv, pos, 0.73, 0.41); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(8, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.00); result += dither;fragColor = vec4(result, bg.a); }"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"beam",
         "speed":0.43,
         "trackMouse":0.04,
         "mouseMomentum":0.5,
         "animating":true,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return vec3((src.x == 1.0) ? 1.0 : min(1.0, dst.x / (1.0 - src.x)), (src.y == 1.0) ? 1.0 : min(1.0, dst.y / (1.0 - src.y)), (src.z == 1.0) ? 1.0 : min(1.0, dst.z / (1.0 - src.z))); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float calculateAngle(vec2 point, vec2 center) { vec2 direction = point - center; float angle = atan(direction.y, direction.x); if (angle < 0.0) { angle += TWO_PI; } return angle; }float angularDifference(float angle1, float angle2) { float diff = abs(angle1 - angle2); if (diff > PI) { diff = TWO_PI - diff; } return diff; }float angularFading(float pointAngle, float peakAngle, float fadeAmount) { float diff = angularDifference(pointAngle, peakAngle); return 1.04 - smoothstep(0.0, fadeAmount, diff); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawRing(vec2 uv, vec2 center, float scale, float angle) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.50, 1.-0.50) * 2.; uv = uv * rot(0.36 * TWO_PI) * skew; center = center * rot(0.36 * TWO_PI) * skew; float ringRadius = scale * 0.5; float distFromCenter = length(uv - center); float ringDist = abs(distFromCenter - ringRadius); float lineRadius = 0.71 * 0.25; float brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));angle = fract(0.36 + uTime * 0.01 + 0.15) * TWO_PI;float pointAngle = calculateAngle(uv, center); float peakAngle = angle; float angleFactor = angularFading(pointAngle, peakAngle, PI * 0.5);brightness *= angleFactor;vec3 ringColor = brightness * pow(1.-ringDist, 3.) * vec3(0.5294117647058824, 0.07058823529411765, 1); return ringColor; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.48, -0.010000000000000009) + mix(vec2(0), (uMousePos-0.5), 0.04); return drawRing(uv, pos, 0.75, 0.36); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(8, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.00); result += dither;fragColor = vec4(result, bg.a); }"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"beam",
         "speed":0.43,
         "trackMouse":0.04,
         "mouseMomentum":0.5,
         "animating":true,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return vec3((src.x == 1.0) ? 1.0 : min(1.0, dst.x / (1.0 - src.x)), (src.y == 1.0) ? 1.0 : min(1.0, dst.y / (1.0 - src.y)), (src.z == 1.0) ? 1.0 : min(1.0, dst.z / (1.0 - src.z))); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float calculateAngle(vec2 point, vec2 center) { vec2 direction = point - center; float angle = atan(direction.y, direction.x); if (angle < 0.0) { angle += TWO_PI; } return angle; }float angularDifference(float angle1, float angle2) { float diff = abs(angle1 - angle2); if (diff > PI) { diff = TWO_PI - diff; } return diff; }float angularFading(float pointAngle, float peakAngle, float fadeAmount) { float diff = angularDifference(pointAngle, peakAngle); return 1.04 - smoothstep(0.0, fadeAmount, diff); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawRing(vec2 uv, vec2 center, float scale, float angle) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.50, 1.-0.50) * 2.; uv = uv * rot(0.36 * TWO_PI) * skew; center = center * rot(0.36 * TWO_PI) * skew; float ringRadius = scale * 0.5; float distFromCenter = length(uv - center); float ringDist = abs(distFromCenter - ringRadius); float lineRadius = 0.78 * 0.25; float brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));angle = fract(0.36 + uTime * 0.01 + 0.15) * TWO_PI;float pointAngle = calculateAngle(uv, center); float peakAngle = angle; float angleFactor = angularFading(pointAngle, peakAngle, PI * 0.5);brightness *= angleFactor;vec3 ringColor = brightness * pow(1.-ringDist, 3.) * vec3(0.25882352941176473, 0, 0.5176470588235295); return ringColor; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.48, -0.010000000000000009) + mix(vec2(0), (uMousePos-0.5), 0.04); return drawRing(uv, pos, 0.81, 0.36); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(8, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.00); result += dither;fragColor = vec4(result, bg.a); }"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"beam",
         "speed":0.99,
         "trackMouse":0,
         "mouseMomentum":0,
         "parentLayer":"1b638854-07f3-41bb-a358-5044ef765225",
         "animating":false,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return vec3((src.x == 1.0) ? 1.0 : min(1.0, dst.x / (1.0 - src.x)), (src.y == 1.0) ? 1.0 : min(1.0, dst.y / (1.0 - src.y)), (src.z == 1.0) ? 1.0 : min(1.0, dst.z / (1.0 - src.z))); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float calculateAngle(vec2 point, vec2 center) { vec2 direction = point - center; float angle = atan(direction.y, direction.x); if (angle < 0.0) { angle += TWO_PI; } return angle; }float angularDifference(float angle1, float angle2) { float diff = abs(angle1 - angle2); if (diff > PI) { diff = TWO_PI - diff; } return diff; }float angularFading(float pointAngle, float peakAngle, float fadeAmount) { float diff = angularDifference(pointAngle, peakAngle); return 1.04 - smoothstep(0.0, fadeAmount, diff); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawRing(vec2 uv, vec2 center, float scale, float angle) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.50, 1.-0.50) * 2.; uv = uv * rot(0.47 * TWO_PI) * skew; center = center * rot(0.47 * TWO_PI) * skew; float ringRadius = scale * 0.5; float distFromCenter = length(uv - center); float ringDist = abs(distFromCenter - ringRadius); float lineRadius = 0.31 * 0.25; float brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));angle = fract(0.47 + uTime * 0.01 + 0.00) * TWO_PI;float pointAngle = calculateAngle(uv, center); float peakAngle = angle; float angleFactor = angularFading(pointAngle, peakAngle, PI * 0.5);brightness *= angleFactor;vec3 ringColor = brightness * pow(1.-ringDist, 3.) * vec3(0, 0.9803921568627451, 0.9333333333333333); return ringColor; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); return drawRing(uv, pos, 0.74, 0.47); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(8, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.00); result += dither;fragColor = vec4(result, bg.a); }"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"beam",
         "speed":1,
         "trackMouse":0,
         "mouseMomentum":0,
         "parentLayer":"0c506d58-fb49-46c1-8165-87bc545d0ae2",
         "animating":false,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float calculateAngle(vec2 point, vec2 center) { vec2 direction = point - center; float angle = atan(direction.y, direction.x); if (angle < 0.0) { angle += TWO_PI; } return angle; }float angularDifference(float angle1, float angle2) { float diff = abs(angle1 - angle2); if (diff > PI) { diff = TWO_PI - diff; } return diff; }float angularFading(float pointAngle, float peakAngle, float fadeAmount) { float diff = angularDifference(pointAngle, peakAngle); return 1.04 - smoothstep(0.0, fadeAmount, diff); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawRing(vec2 uv, vec2 center, float scale, float angle) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.50, 1.-0.50) * 2.; uv = uv * rot(0.00 * TWO_PI) * skew; center = center * rot(0.00 * TWO_PI) * skew; float ringRadius = scale * 0.5; float distFromCenter = length(uv - center); float ringDist = abs(distFromCenter - ringRadius); float lineRadius = 0.22 * 0.25; float brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));angle = fract(0.00 + uTime * 0.01 + 0.09) * TWO_PI;float pointAngle = calculateAngle(uv, center); float peakAngle = angle; float angleFactor = angularFading(pointAngle, peakAngle, PI * 0.5);brightness *= angleFactor;vec3 ringColor = brightness * pow(1.-ringDist, 3.) * vec3(0.4, 0.09803921568627451, 1); return ringColor; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); return drawRing(uv, pos, 0.67, 0.00); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.00); result += dither;fragColor = vec4(result, bg.a); }"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"blur",
         "trackMouse":0,
         "mouseMomentum":0,
         "animating":false,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const int kernelSize = 36; float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); vec2 pos = vec2(0.49890350877192985, 0.141652793784949) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos));float amt = 0 <= 1 ? 6. : 11.; float amount = (0.25 * amt) * ease(0, mix(inner, outer, 0.70)); color += texture(tex, uv) * getGaussianWeight(0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.50, 1. - 0.50)) * getGaussianWeight(i); }float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; return color; }vec4 blur(vec2 uv, vec2 direction) { return GaussianBlur(uTexture, uv, direction); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 0 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction); fragColor = color;}",
            "#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const int kernelSize = 36; float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); vec2 pos = vec2(0.49890350877192985, 0.141652793784949) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos));float amt = 1 <= 1 ? 6. : 11.; float amount = (0.25 * amt) * ease(0, mix(inner, outer, 0.70)); color += texture(tex, uv) * getGaussianWeight(0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.50, 1. - 0.50)) * getGaussianWeight(i); }float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; return color; }vec4 blur(vec2 uv, vec2 direction) { return GaussianBlur(uTexture, uv, direction); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 1 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction); fragColor = color;}",
            "#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const int kernelSize = 36; float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); vec2 pos = vec2(0.49890350877192985, 0.141652793784949) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos));float amt = 2 <= 1 ? 6. : 11.; float amount = (0.25 * amt) * ease(0, mix(inner, outer, 0.70)); color += texture(tex, uv) * getGaussianWeight(0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.50, 1. - 0.50)) * getGaussianWeight(i); }float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; return color; }vec4 blur(vec2 uv, vec2 direction) { return GaussianBlur(uTexture, uv, direction); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 2 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction); fragColor = color;}",
            "#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const int kernelSize = 36; float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); vec2 pos = vec2(0.49890350877192985, 0.141652793784949) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos));float amt = 3 <= 1 ? 6. : 11.; float amount = (0.25 * amt) * ease(0, mix(inner, outer, 0.70)); color += texture(tex, uv) * getGaussianWeight(0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.50, 1. - 0.50)) * getGaussianWeight(i); }float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; return color; }vec4 blur(vec2 uv, vec2 direction) { return GaussianBlur(uTexture, uv, direction); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 3 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction); fragColor = color;}"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "downSample":true,
            "depth":false,
            "uniforms":{
               
            },
            "passes":[
               {
                  "prop":"vertical",
                  "value":1,
                  "downSample":true
               },
               {
                  "prop":"vertical",
                  "value":2,
                  "downSample":true
               },
               {
                  "prop":"vertical",
                  "value":3,
                  "downSample":true
               }
            ]
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"wisps",
         "speed":0.76,
         "trackMouse":0,
         "mouseMomentum":0,
         "parentLayer":"e6ce5e92-4934-4b2a-ad76-0a591e5c5a24",
         "animating":false,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return vec3((src.x > 0.5) ? max(dst.x, 2.0 * (src.x - 0.5)) : min(dst.x, 2.0 * src.x), (src.x > 0.5) ? max(dst.y, 2.0 * (src.y - 0.5)) : min(dst.y, 2.0 * src.y), (src.z > 0.5) ? max(dst.z, 2.0 * (src.z - 0.5)) : min(dst.z, 2.0 * src.z)); }out vec4 fragColor; const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 hash(vec2 p) { p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3))); return -1.0 + 2.0 * fract(sin(p) * 43758.5453123); }vec3 voronoi_static(vec2 st) { vec2 i_st = floor(st); vec2 f_st = fract(st);float m_dist = 1.0; vec2 m_point;for (int y = -1; y <= 1; y++) { for (int x = -1; x <= 1; x++) { vec2 neighbor = vec2(float(x), float(y)); vec2 point = hash(i_st + neighbor); point = 0.5 + 0.5 * sin(5. + 6.2831*point); vec2 diff = neighbor + point - f_st; float dist = length(diff); if (dist < m_dist) { m_dist = dist; m_point = point; } } }return vec3(m_dist, m_point); }void main() { vec2 uv = vTextureCoord;vec4 bg = texture(uTexture, uv);vec4 color = vec4(0,0,0,1); vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1);vec2 mPos = mix(vec2(0), (uMousePos-0.5), 0.00);uv -= vec2(0.5, 0.20000000000000007); uv *= aspectRatio; uv = uv * rot(0.00 * 2. * PI); uv *= 40. * 1.00; uv *= mix(vec2(1), vec2(1, 0), 0.00); uv /= aspectRatio;mPos = mPos * rot(0.00 * -2. * PI);vec2 st1 = uv - (mPos * 30. * 1.00); vec2 st2 = uv - (mPos * 40. * 1.00);vec2 mouse1 = st1 + vec2(0, uTime * 0.79 * -0.05); vec2 mouse2 = st2 + vec2(0, uTime * 0.79 * -0.05);vec3 voro_static = voronoi_static(mouse1 * aspectRatio); vec3 voro_static2 = voronoi_static(mouse2 * aspectRatio + vec2(10)); float dist = smoothstep(0., 0.8, voro_static.x); float dist2 = smoothstep(0., 0.8, voro_static2.x);float shimmer1 = mix(1., (sin(voro_static.z * voro_static.y * uTime * 0.5) + 1.), 1.00); float shimmer2 = mix(1., (sin(voro_static2.z * voro_static2.y * uTime * 0.5) + 1.), 1.00); float radius1 = 0.02 * 0.14 * shimmer1; float radius2 = 0.04 * 0.14 * shimmer2; vec3 pass1 = vec3(radius1/dist); vec3 pass2 = vec3(radius2/dist2); color.rgb = (pass1 + pass2) * vec3(1, 1, 1) * mix(1., bg.r, 0.13);color.rgb = blend(16, bg.rgb, color.rgb); fragColor = color;}"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"mouse",
         "amount":0.17,
         "animating":false,
         "mouseMomentum":0,
         "isMask":0,
         "states":{
            "appear":[
               {
                  "type":"appear",
                  "id":"9ba393b0-bd28-44f9-bc42-aed8f3582d77",
                  "prop":"amount",
                  "transition":{
                     "ease":"easeInOutQuart",
                     "duration":0,
                     "delay":1000
                  },
                  "complete":false,
                  "progress":0,
                  "initialStateSet":false,
                  "value":0,
                  "uniformData":{
                     "type":"1f",
                     "name":"uAmount"
                  }
               }
            ],
            "scroll":[
               
            ],
            "hover":[
               
            ]
         },
         "compiledFragmentShaders":[
            "#version 300 es\nprecision highp float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; uniform vec2 uResolution;uniform float uAmount;const float PI = 3.1415926; const float ITERATIONS = 24.0;out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec3 chromatic_aberration(vec3 color, vec2 uv, vec2 offset) { vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }vec2 angleToDir(float angle) { float rad = angle * 2.0 * PI; return vec2(cos(rad), sin(rad)); }vec4 defaultTrail(vec2 uv, vec2 mouseDir) { vec4 color = vec4(0); vec2 distorted = mouseDir * 0.4; color = texture(uTexture, uv - distorted); color.rgb = chromatic_aberration(color.rgb, uv - distorted, distorted * 0.00 * 0.12); return color; }vec4 getTrailColor(vec2 uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); float aspectRatio = uResolution.x / uResolution.y;return defaultTrail(uv, mouseDir); }void main() { vec2 uv = vTextureCoord; vec2 pingpongUv = uv;vec3 mouseRgb = texture(uPingPongTexture, pingpongUv).rgb; vec3 mouseTrail = rgb2hsv(mouseRgb);float angle = mouseTrail.x; float strength = mouseTrail.z * (uAmount * 2.0); vec2 direction = angleToDir(angle); vec2 mouseDir = direction * strength;vec4 color = getTrailColor(uv, mouseDir, strength);fragColor = color; }",
            "#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uPingPongTexture; uniform vec2 uPreviousMousePos; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.1415926; const float TWOPI = 6.2831852;out vec4 fragColor;vec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 liquify(vec2 st, float angle) { float aspectRatio = uResolution.x / uResolution.y; st.x *= aspectRatio; st = st * rot(angle * TWOPI); float amplitude = 0.003; for (float i = 1.0; i <= 5.0; i++) { st = st * rot(i / 5.0 * PI * 2.0); st += vec2( amplitude * cos(i * 5.0 * st.y + uTime * 0.02), amplitude * sin(i * 5.0 * st.x + uTime * 0.02) ); } st = st * rot(-angle * TWOPI); st.x /= aspectRatio; return st; }void main() { float aspectRatio = uResolution.x / uResolution.y; vec2 uv = vTextureCoord; vec2 correctedUv = uv * vec2(aspectRatio, 1.0);vec2 dir = (uMousePos - uPreviousMousePos) * vec2(aspectRatio, 1.0); float dist = length(dir); dir = normalize(dir);float rad = 0.10 * 0.4 * mix(aspectRatio, 1.0, 0.5); float angle = atan(dir.y, dir.x); if (angle < 0.0) angle += TWOPI;uv = mix(uv, liquify(uv, smoothstep(0.0, 1.0, angle)), 0.86);float t = clamp(dot(correctedUv - uPreviousMousePos * vec2(aspectRatio, 1.0), dir) / dist, 0.0, 1.0); vec2 closestPoint = mix(uPreviousMousePos, uMousePos, t) * vec2(aspectRatio, 1.0); float distanceToLine = distance(correctedUv, closestPoint);float s = smoothstep(rad, rad * 0.00, distanceToLine);vec3 color = vec3(angle / TWOPI, 1.0, 1.0); vec3 mouseColor = hsv2rgb(color);vec3 lastFrameColor = texture(uPingPongTexture, mix(uv, uv / 1.03 + 0.015, 0.52)).rgb; vec3 draw = mix(lastFrameColor, mouseColor, min(1.0, dist * s));fragColor = vec4(draw * pow(0.66, 0.1), 1.0); }"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }",
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            {
               "min":992,
               "name":"Desktop",
               "max":null,
               "props":{
                  "mouseMomentum":1,
                  "speed":0.15,
                  "specular":0.85,
                  "frost":0,
                  "trackMouse":0.4,
                  "rounding":1,
                  "trackMouseMove":0.01,
                  "shapeControl":0,
                  "patternScale":0.05,
                  "showBg":1,
                  "dispersion":0.7,
                  "refraction":0.6,
                  "fillOpacity":0.15,
                  "fresnel":1.5,
                  "textureAmount":0,
                  "extrude":1,
                  "twist":{
                     "type":"Vec2",
                     "_x":0,
                     "_y":0
                  },
                  "scale":-0.1,
                  "pos":{
                     "type":"Vec2",
                     "_x":0.5,
                     "_y":0.8
                  }
               }
            },
            {
               "max":991,
               "name":"Tablet",
               "props":{
                  "trackMouse":0.5
               },
               "min":576
            },
            {
               "max":575,
               "min":0,
               "name":"Mobile",
               "props":{
                  "trackMouse":0.2
               }
            }
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"sdf_shape",
         "scale":-0.1,
         "speed":0.15,
         "trackMouseMove":0.01,
         "mouseMomentum":1,
         "trackMouse":0.4,
         "animating":false,
         "isMask":0,
         "states":{
            "appear":[
               
            ],
            "scroll":[
               {
                  "type":"scroll",
                  "id":"eaee57ed-cd2a-4a5b-af15-007151b0fbd8",
                  "prop":"scale",
                  "progress":0,
                  "momentum":1,
                  "range":0.61,
                  "offset":0,
                  "mode":"scrollIntoView",
                  "delta":0.01,
                  "sceneTop":0,
                  "startScroll":0,
                  "endScroll":0,
                  "lastScrollTop":0,
                  "absScrollValue":true,
                  "value":0.48,
                  "uniformData":{
                     "type":"1f",
                     "name":"uScale"
                  }
               }
            ],
            "hover":[
               
            ]
         },
         "compiledFragmentShaders":[
            "#version 300 es\nprecision highp float;in vec2 vTextureCoord; uniform sampler2D uTexture;uniform float uScale; uniform float uTime;uniform float uTrackMouse; uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.141592653; const float PI2 = 6.283185306; const float DISP_STEPS = 12.; const vec3 viewDir = vec3(0,0, -4.25);const mat3 ROT_Y_90 = mat3( 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 0.0 );const mat3 ROT_Z_90 = mat3( 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 );const mat3 ROT_X_90 = mat3( 1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0 );float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); }mat3 rotY(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c); }mat3 rotX(float ang) { float c = cos(ang), s = sin(ang); return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c); }mat3 rotZ(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0); }vec3 twistY(vec3 p, float amount) { float c = cos(amount * p.y); float s = sin(amount * p.y); mat2 m = mat2(c, -s, s, c); return vec3(m * p.xz, p.y); }vec3 twistX(vec3 p, float amount) { float c = cos(amount * p.x); float s = sin(amount * p.x); mat2 m = mat2(c, -s, s, c); return vec3(p.x, m * p.yz); }float sdfCylinder(vec3 p, float radius, float height) { vec2 d = abs(vec2(length(p.xz) - radius, p.y)) - vec2(radius, height * 0.5); return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)); }float sdStar5(vec2 p, float r, float rf) { const vec2 k1 = vec2(0.809016994375, -0.587785252292); const vec2 k2 = vec2(-k1.x,k1.y); p.x = abs(p.x); p -= 2.0*max(dot(k1,p),0.0)*k1; p -= 2.0*max(dot(k2,p),0.0)*k2; p.x = abs(p.x); p.y -= r; vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1); float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r ); return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y); }vec3 getRepeat(vec3 p) { float spacing = (0.50 + 1.00 * 0.38) * 8.; return p; }vec3 getThreeDRepeat(vec3 p) { float spacing = (0.50 + 1.00 * 0.38) * 8.; return p; }vec3 getAdjustedP(vec3 p) { float scaleFactor = uScale < 1e-7 ? 1e7 : 1.0/uScale; vec3 adjustedP = p * scaleFactor;vec2 twist = vec2(0, 0);adjustedP.xy *= vec2(uResolution.x / uResolution.y, 1);adjustedP *= (1. + (1.00 + 0.01));vec2 mousePos = mix(vec2(0), uMousePos - 0.5, uTrackMouse); vec2 axis = vec2(-1. * vec3(0.5, 0.5039630118890357, -0.2295).y - 1. + mousePos.y/PI, vec3(0.5, 0.5039630118890357, -0.2295).x + mousePos.x/PI) * 2.;adjustedP = getRepeat(adjustedP);float baseTime = uTime * 0.02; float timeX = vec3(0, 1, 0).x * baseTime; float timeY = vec3(0, 1, 0).y * baseTime; float timeZ = vec3(0, 1, 0).z * baseTime;mat3 rotYMat = rotY(axis.y * PI); mat3 rotXMat = rotX(axis.x * PI); mat3 rotZMat = rotZ(vec3(0.5, 0.5039630118890357, -0.2295).z * 2.0 * PI);mat3 combinedRotation = rotZMat * rotYMat * rotXMat; mat3 combinedAnimation = rotZ(timeZ) * rotX(timeX) * rotY(timeY);adjustedP = combinedRotation * adjustedP; adjustedP = combinedAnimation * adjustedP; adjustedP = getThreeDRepeat(adjustedP); adjustedP = mix(adjustedP, twistY(adjustedP, -1.0 * twist.y), step(0.0, abs(twist.y))); adjustedP = mix(adjustedP, twistX(adjustedP, -1.0 * twist.x), step(0.0, abs(twist.x)));return adjustedP; }float getMergedSDF(vec3 p) { p = getAdjustedP(p); return sdfCylinder(p, 0.7, 0.05 + 0.25 * 0.00); }float fresnel(vec3 eyeVector, vec3 worldNormal, float power) { float fresnelFactor = 1.0 - abs(dot(eyeVector, worldNormal)); return pow(fresnelFactor, power); }vec3 noFrostOrDispersion(vec3 rd, vec3 normal) { float ior = 1.0 / (1.0 + 0.60 * 0.25); vec3 refractedRay = refract(rd, normal, ior); return texture(uTexture, vTextureCoord - refractedRay.xy).rgb; }vec3 frostOrDispersion(vec3 rd, vec3 normal) { vec3 refractionColor = vec3(0); float iorBase = 1. + 0.60 * 0.25;vec3 dispCoefficients = vec3(0.03, 0.06, 0.1) * 0.70 * 1.2;for(float i = 0.; i < DISP_STEPS; i++) { float step = i / DISP_STEPS; vec3 disp = step * dispCoefficients; vec3 ior = 1.0 / (iorBase + disp);vec3 refractedRayR = refract(rd, normal, ior.r); vec3 refractedRayG = refract(rd, normal, ior.g); vec3 refractedRayB = refract(rd, normal, ior.b);refractionColor.r += texture(uTexture, vTextureCoord - refractedRayR.xy).r; refractionColor.g += texture(uTexture, vTextureCoord - refractedRayG.xy).g; refractionColor.b += texture(uTexture, vTextureCoord - refractedRayB.xy).b; }return clamp(refractionColor / DISP_STEPS, 0.0, 1.0); }vec3 calculateNormal(vec3 p, float eps) { float dx = getMergedSDF(p + vec3(eps, 0.0, 0.0)) - getMergedSDF(p - vec3(eps, 0.0, 0.0)); float dy = getMergedSDF(p + vec3(0.0, eps, 0.0)) - getMergedSDF(p - vec3(0.0, eps, 0.0)); float dz = getMergedSDF(p + vec3(0.0, 0.0, eps)) - getMergedSDF(p - vec3(0.0, 0.0, eps)); return normalize(vec3(dx, dy, dz)); }vec3 sampleTexture(vec3 rd, vec3 normal) {return frostOrDispersion(rd, normal); return noFrostOrDispersion(rd, normal); }float scene(vec3 p) { return max(0., getMergedSDF(p) - 1.00) * max(uScale, 0.0000000001); }float getPixelSize() { return 1.0 / min(uResolution.x, uResolution.y); }const int STEPS = 128; const float MAX_DISTANCE = 40.0;vec4 rayMarch(vec3 ro, vec3 rd, float min_dist) { float traveled = 0.; vec3 entryPoint = vec3(0.0); vec3 entryNormal = vec3(0.0); float partialAlpha = 0.0;for (int i = 0; i < STEPS; ++i) { vec3 currentPos = ro + rd * traveled; float distance = scene(currentPos); float pixelSize = getPixelSize();if (distance < pixelSize * 2.) { partialAlpha = 0.5; entryPoint = currentPos; entryNormal = calculateNormal(entryPoint, pixelSize); }if (distance < pixelSize) { partialAlpha = 1.; entryPoint = currentPos; entryNormal = calculateNormal(entryPoint, pixelSize); break; }if(traveled < 0.05) { traveled += distance * 0.9; } else { traveled += distance; } if (traveled > MAX_DISTANCE) break; }if (partialAlpha == 0.0) { return texture(uTexture, vTextureCoord); }vec4 bg = texture(uTexture, vTextureCoord);vec3 samplePosition = mix(rd, entryPoint, 0.00); vec3 refractionColor = sampleTexture(samplePosition, entryNormal);vec3 lightDir = vec3(((vec2(vec2(0.25, 0.25).x, 1.-vec2(0.25, 0.25).y) - 0.333) * 3.) - vec2(0.5, 0.09999999999999987), -3.0); vec3 normLightDir = normalize(lightDir);float lightAndShadow = dot(entryNormal, normLightDir); vec3 lightColor = mix(vec3(1), vec3(0.1450980392156863, 0.07450980392156863, 0.5725490196078431), 1. - 0.15); vec3 fresnelEffect = fresnel(rd, entryNormal, 8.0) * 1.50 * vec3(0.1450980392156863, 0.07450980392156863, 0.5725490196078431); vec3 halfwayDir = normalize(lightDir + rd); float specFactor = pow(max(dot(entryNormal, halfwayDir), 0.0), 64.0 * 0.85 + 0.01); vec3 specularEffect = specFactor * 0.85 * lightColor; vec3 combinedEffects = fresnelEffect + specularEffect; vec3 finalColor = mix(refractionColor, vec3(0.1450980392156863, 0.07450980392156863, 0.5725490196078431) * lightAndShadow, 0.15); finalColor += combinedEffects; vec4 outputColor = mix(bg, vec4(finalColor, 1.), partialAlpha);return outputColor; }out vec4 fragColor;void main() { vec2 pos = vec2(0.5, 0.09999999999999987) + mix(vec2(0), (uMousePos-0.5), 0.01); vec2 uv = vTextureCoord - pos; float fovFactor = tan(radians(20.) * 0.5); vec3 rd = vec3(uv * fovFactor, 0.5);float mdist = 0.004; vec4 col = rayMarch(viewDir, rd, mdist); float dither = (rand(vTextureCoord.xy) - 0.5) / 255.0; col += dither; fragColor = col;}"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               "trackMouse":{
                  "name":"uTrackMouse",
                  "type":"1f",
                  "value":0
               }
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"coloration",
         "animating":false,
         "mouseMomentum":0,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;float hueToRgb(float p, float q, float t) { if (t < 0.0) t += 1.0; if (t > 1.0) t -= 1.0; if (t < 1.0 / 6.0) return p + (q - p) * 6.0 * t; if (t < 1.0 / 2.0) return q; if (t < 2.0 / 3.0) return p + (q - p) * (2.0 / 3.0 - t) * 6.0; return p; }vec3 hslToRgb(vec3 hsl) { float h = hsl.x; float s = hsl.y; float l = hsl.z; vec3 rgb = vec3(l); if (s != 0.0) { float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s; float p = 2.0 * l - q; rgb.r = hueToRgb(p, q, h + 1.0 / 3.0); rgb.g = hueToRgb(p, q, h); rgb.b = hueToRgb(p, q, h - 1.0 / 3.0); } return rgb; }vec3 rgbToHsl(vec3 rgb) { float max = max(max(rgb.r, rgb.g), rgb.b); float min = min(min(rgb.r, rgb.g), rgb.b); float h, s, l = (max + min) / 2.0;if (max == min) { h = s = 0.0; } else { float d = max - min; s = l > 0.5 ? d / (2.0 - max - min) : d / (max + min); if (max == rgb.r) { h = (rgb.g - rgb.b) / d + (rgb.g < rgb.b ? 6.0 : 0.0); } else if (max == rgb.g) { h = (rgb.b - rgb.r) / d + 2.0; } else if (max == rgb.b) { h = (rgb.r - rgb.g) / d + 4.0; } h /= 6.0; }return vec3(h, s, l); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); color.rgb = rgbToHsl(color.rgb); color.x = fract(color.x + 1.05); color.y = clamp(color.y * 1.30, 0.0, 1.0); color.z = clamp(color.z + -0.02, 0.0, 1.0); color.rgb = hslToRgb(color.rgb); color.rgb = 1.25 * (color.rgb - 0.5) + 0.5; color.r = clamp(color.r + -0.13, 0.0, 1.0); color.b = clamp(color.b - -0.13, 0.0, 1.0); color.rgb = pow(color.rgb, vec3(1.0 / (0.02 + 1.))); vec3 avgSurround = ( texture(uTexture, uv + vec2(-1.0, 0.0) / uResolution).rgb + texture(uTexture, uv + vec2(1.0, 0.0) / uResolution).rgb + texture(uTexture, uv + vec2(0.0, -1.0) / uResolution).rgb + texture(uTexture, uv + vec2(0.0, 1.0) / uResolution).rgb) / 4.0; color.rgb += 0.56 * (color.rgb - avgSurround);color = vec4(clamp(color.rgb, 0.0, 1.0), color.a); fragColor = color;}"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"vignette",
         "radius":0,
         "trackMouse":0,
         "mouseMomentum":0,
         "parentLayer":"dd7fb340-87cb-4279-8a27-b7fa983967ee",
         "animating":false,
         "isMask":1,
         "states":{
            "appear":[
               {
                  "type":"appear",
                  "id":"eceda037-4a07-47dd-a5a6-c606ba6fa21c",
                  "prop":"radius",
                  "transition":{
                     "ease":"easeInOutSine",
                     "delay":900,
                     "duration":1200
                  },
                  "complete":false,
                  "progress":0,
                  "initialStateSet":false,
                  "value":1,
                  "uniformData":{
                     "type":"1f",
                     "name":"uRadius"
                  }
               }
            ],
            "scroll":[
               {
                  "type":"scroll",
                  "id":"15aa8071-4de1-4c56-8117-1e5091cb72c6",
                  "prop":"radius",
                  "progress":0,
                  "momentum":0.5,
                  "range":0.5,
                  "offset":0,
                  "mode":"scrollIntoView",
                  "delta":0.01,
                  "sceneTop":0,
                  "startScroll":0,
                  "endScroll":0,
                  "lastScrollTop":0,
                  "absScrollValue":true,
                  "value":1,
                  "uniformData":{
                     "type":"1f",
                     "name":"uRadius"
                  }
               }
            ],
            "hover":[
               
            ]
         },
         "compiledFragmentShaders":[
            "#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uRadius; uniform sampler2D uMaskTexture; uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src; }out vec4 fragColor; void main() { vec2 uv = vTextureCoord;vec4 color = texture(uTexture, uv); float colorAlpha = color.a; float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114)); float displacement = (luma - 0.5) * 0.00 * 0.5; vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.) * vec2(0.50, 1.-0.50); float scaledRadius = uRadius * 0.5;float adjustedRadius = scaledRadius + 1.00 * scaledRadius; float innerEdge = scaledRadius - 1.00 * scaledRadius * 0.5; float outerEdge = scaledRadius + 1.00 * scaledRadius * 0.5;vec2 pos = vec2(0.5076754385964912, 0.37540263765649695) + mix(vec2(0), (uMousePos-0.5), 0.00);float radius = length(uv * aspectRatio - pos * aspectRatio); float falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius);if(0 > 0) { vec3 blended = blend(0, vec3(1, 1, 1), color.rgb); color.rgb = mix(color.rgb, blended, falloff * 1.00); } else { color.rgb = mix(color.rgb, mix(color.rgb, vec3(1, 1, 1), 1.00), falloff); }color.a = mix((1. - falloff), 1., 1.00); vec2 maskPos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - maskPos); color = color * (maskColor.a * maskColor.a); fragColor = color;}"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"dither",
         "speed":0.58,
         "animating":true,
         "mouseMomentum":0,
         "isMask":0,
         "compiledFragmentShaders":[
            "#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBlueNoise;uniform float uTime;uniform vec2 uResolution;const int MAX_LEVEL = 4;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }float getBlueNoise(vec2 st, vec2 offset, float size) { ivec2 texSize = textureSize(uBlueNoise, 0); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution/size)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0) + offset) * vec2(texSize)) % texSize, 0); return blueNoise.r; }vec3 dither(vec3 color, vec2 st) { float delta = floor(uTime); vec2 offset = vec2(random(vec2(123,16) + delta), random(vec2(56,96) + delta)); float noise = 0.0; noise = getBlueNoise(st, offset, 2.); color += (noise - 0.505) * 0.80; return round(color * (1.0 / 0.80)) * 0.80; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float delta = floor(uTime); vec4 color = texture(uTexture, uv);if(color.a == 0.) { fragColor = vec4(0); return; }color.rgb = mix(color.rgb, dither(color.rgb, uv), 0.80); fragColor = color;}"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            },
            "texture":{
               "src":"https://assets.unicorn.studio/media/blue_noise_med.png",
               "sampler":"uBlueNoise"
            }
         }
      },
      {
         "breakpoints":[
            
         ],
         "visible":true,
         "aspectRatio":1,
         "layerType":"effect",
         "type":"vignette",
         "radius":0,
         "trackMouse":0,
         "mouseMomentum":0,
         "parentLayer":"110d5985-baf8-4cc1-be5e-a67432b2c987",
         "animating":false,
         "isMask":1,
         "states":{
            "appear":[
               {
                  "type":"appear",
                  "id":"740ce654-1374-4495-b29f-64544bed3ffd",
                  "prop":"radius",
                  "transition":{
                     "delay":900,
                     "ease":"easeInOutSine",
                     "duration":1200
                  },
                  "complete":false,
                  "progress":0,
                  "initialStateSet":false,
                  "value":1,
                  "uniformData":{
                     "type":"1f",
                     "name":"uRadius"
                  }
               }
            ],
            "scroll":[
               {
                  "type":"scroll",
                  "id":"c8308227-829d-4207-836e-77bd9ff93a2a",
                  "prop":"radius",
                  "progress":0,
                  "momentum":0.25,
                  "range":0.5,
                  "offset":0,
                  "mode":"scrollIntoView",
                  "delta":0.01,
                  "sceneTop":0,
                  "startScroll":0,
                  "endScroll":0,
                  "lastScrollTop":0,
                  "absScrollValue":true,
                  "value":1,
                  "uniformData":{
                     "type":"1f",
                     "name":"uRadius"
                  }
               }
            ],
            "hover":[
               
            ]
         },
         "compiledFragmentShaders":[
            "#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uRadius; uniform sampler2D uMaskTexture; uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src; }out vec4 fragColor; void main() { vec2 uv = vTextureCoord;vec4 color = texture(uTexture, uv); float colorAlpha = color.a; float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114)); float displacement = (luma - 0.5) * 0.00 * 0.5; vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.) * vec2(0.50, 1.-0.50); float scaledRadius = uRadius * 0.5;float adjustedRadius = scaledRadius + 1.00 * scaledRadius; float innerEdge = scaledRadius - 1.00 * scaledRadius * 0.5; float outerEdge = scaledRadius + 1.00 * scaledRadius * 0.5;vec2 pos = vec2(0.5076754385964912, 0.37540263765649695) + mix(vec2(0), (uMousePos-0.5), 0.00);float radius = length(uv * aspectRatio - pos * aspectRatio); float falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius);if(0 > 0) { vec3 blended = blend(0, vec3(1, 1, 1), color.rgb); color.rgb = mix(color.rgb, blended, falloff * 1.00); } else { color.rgb = mix(color.rgb, mix(color.rgb, vec3(1, 1, 1), 1.00), falloff); }color.a = mix((1. - falloff), 1., 1.00); vec2 maskPos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - maskPos); color = color * (maskColor.a * maskColor.a); fragColor = color;}"
         ],
         "compiledVertexShaders":[
            "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
         ],
         "data":{
            "depth":false,
            "uniforms":{
               
            }
         }
      }
   ],
   "options":{
      "name":"aura ring",
      "fps":24,
      "dpi":1.5,
      "scale":1,
      "includeLogo":false,
      "isProduction":false,
      "freePlan":false
   },
   "version":"1.3.2"
}
